--- parser-upstream/ast_helper.ml
+++ parser-standard/ast_helper.ml
@@@@
   let open_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_open (a, b))
   let letop ?loc ?attrs let_ ands body =
     mk ?loc ?attrs (Pexp_letop {let_; ands; body})
   let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
   let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable
+  let hole  ?loc ?attrs () = mk ?loc ?attrs Pexp_hole
 
   let case lhs ?guard rhs =
     {
      pc_lhs = lhs;
      pc_guard = guard;
@@@@
     mk ?loc ?attrs (Pmod_functor (arg, body))
   let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
   let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
   let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
   let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
+  let hole ?loc ?attrs () = mk ?loc ?attrs Pmod_hole
 end
 
 module Sig = struct
   let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}
 
--- parser-upstream/ast_helper.mli
+++ parser-standard/ast_helper.mli
@@@@
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
     val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression
 
     val case: pattern -> ?guard:expression -> expression -> case
     val binding_op: str -> pattern -> expression -> loc -> binding_op
+    val hole: ?loc:loc -> ?attrs:attrs -> unit -> expression
   end
 
 (** Value declarations *)
 module Val:
   sig
@@@@
       module_expr
     val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->
       module_expr
     val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
+    val hole: ?loc:loc -> ?attrs:attrs -> unit -> module_expr
   end
 
 (** Signature items *)
 module Sig:
   sig
--- parser-upstream/ast_mapper.ml
+++ parser-standard/ast_mapper.ml
@@@@
   type_exception: mapper -> type_exception -> type_exception;
   type_kind: mapper -> type_kind -> type_kind;
   value_binding: mapper -> value_binding -> value_binding;
   value_description: mapper -> value_description -> value_description;
   with_constraint: mapper -> with_constraint -> with_constraint;
+  directive_argument: mapper -> directive_argument -> directive_argument;
+  toplevel_directive: mapper -> toplevel_directive -> toplevel_directive;
+  toplevel_phrase: mapper -> toplevel_phrase -> toplevel_phrase;
 }
 
 let map_fst f (x, y) = (f x, y)
 let map_snd f (x, y) = (x, f y)
 let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
@@@@
     | Pmod_constraint (m, mty) ->
         constraint_ ~loc ~attrs (sub.module_expr sub m)
                     (sub.module_type sub mty)
     | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
     | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)
+    | Pmod_hole -> hole ~loc ~attrs ()
 
   let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
     let open Str in
     let loc = sub.location sub loc in
     match desc with
@@@@
     | Pexp_letop {let_; ands; body} ->
         letop ~loc ~attrs (sub.binding_op sub let_)
           (List.map (sub.binding_op sub) ands) (sub.expr sub body)
     | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
     | Pexp_unreachable -> unreachable ~loc ~attrs ()
+    | Pexp_hole -> hole ~loc ~attrs ()
 
   let map_binding_op sub {pbop_op; pbop_pat; pbop_exp; pbop_loc} =
     let open Exp in
     let op = map_loc sub pbop_op in
     let pat = sub.pat sub pbop_pat in
@@@@
          | PStr x -> PStr (this.structure this x)
          | PSig x -> PSig (this.signature this x)
          | PTyp x -> PTyp (this.typ this x)
          | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
       );
+
+    directive_argument =
+      (fun this a ->
+         { pdira_desc= a.pdira_desc
+         ; pdira_loc= this.location this a.pdira_loc} );
+
+    toplevel_directive =
+      (fun this d ->
+         { pdir_name= map_loc this d.pdir_name
+         ; pdir_arg= map_opt (this.directive_argument this) d.pdir_arg
+         ; pdir_loc= this.location this d.pdir_loc } );
+
+    toplevel_phrase =
+      (fun this -> function
+         | Ptop_def s -> Ptop_def (this.structure this s)
+         | Ptop_dir d -> Ptop_dir (this.toplevel_directive this d) );
   }
 
 let extension_of_error {kind; main; sub} =
   if kind <> Location.Report_error then
     raise (Invalid_argument "extension_of_error: expected kind Report_error");
@@@@
       | "tool_name" ->
           tool_name_ref := get_string payload
       | "include_dirs" ->
           Clflags.include_dirs := get_list get_string payload
       | "load_path" ->
-          (* Duplicates Compmisc.auto_include, since we can't reference Compmisc
-             from this module. *)
-          let auto_include find_in_dir fn =
-            if !Clflags.no_std_include then
-              raise Not_found
-            else
-              let alert = Location.auto_include_alert in
-              Load_path.auto_include_otherlibs alert find_in_dir fn
-          in
-          Load_path.init ~auto_include (get_list get_string payload)
+          ()
       | "open_modules" ->
           Clflags.open_modules := get_list get_string payload
       | "for_package" ->
           Clflags.for_package := get_option get_string payload
       | "debug" ->
--- parser-upstream/ast_mapper.mli
+++ parser-standard/ast_mapper.mli
@@@@
   type_exception: mapper -> type_exception -> type_exception;
   type_kind: mapper -> type_kind -> type_kind;
   value_binding: mapper -> value_binding -> value_binding;
   value_description: mapper -> value_description -> value_description;
   with_constraint: mapper -> with_constraint -> with_constraint;
+  directive_argument: mapper -> directive_argument -> directive_argument;
+  toplevel_directive: mapper -> toplevel_directive -> toplevel_directive;
+  toplevel_phrase: mapper -> toplevel_phrase -> toplevel_phrase;
 }
 (** A mapper record implements one "method" per syntactic category,
     using an open recursion style: each method takes as its first
     argument the mapper to be applied to children in the syntax
     tree. *)
--- parser-upstream/asttypes.mli
+++ parser-standard/asttypes.mli
@@@@
 
 type override_flag = Override | Fresh
 
 type closed_flag = Closed | Open
 
+type global_flag =
+  | Global
+  | Nonlocal
+  | Nothing
+
 type label = string
 
 type arg_label =
     Nolabel
   | Labelled of string (** [label:T -> ...] *)
--- parser-upstream/lexer.mll
+++ parser-standard/lexer.mll
@@@@
     "false", FALSE;
     "for", FOR;
     "fun", FUN;
     "function", FUNCTION;
     "functor", FUNCTOR;
+    "global_", GLOBAL;
     "if", IF;
     "in", IN;
     "include", INCLUDE;
     "inherit", INHERIT;
     "initializer", INITIALIZER;
     "lazy", LAZY;
     "let", LET;
+    "local_", LOCAL;
     "match", MATCH;
     "method", METHOD;
     "module", MODULE;
     "mutable", MUTABLE;
     "new", NEW;
+    "nonlocal_", NONLOCAL;
     "nonrec", NONREC;
     "object", OBJECT;
     "of", OF;
     "open", OPEN;
     "or", OR;
@@@@
 let is_keyword name = Hashtbl.mem keyword_table name
 
 let check_label_name lexbuf name =
   if is_keyword name then error lexbuf (Keyword_as_label name)
 
+(* To "unlex" a few characters *)
+let set_lexeme_length buf n = (
+  let open Lexing in
+  if n < 0 then
+    invalid_arg "set_lexeme_length: offset should be positive";
+  if n > buf.lex_curr_pos - buf.lex_start_pos then
+    invalid_arg "set_lexeme_length: offset larger than lexeme";
+  buf.lex_curr_pos <- buf.lex_start_pos + n;
+  buf.lex_curr_p <- {buf.lex_start_p
+                     with pos_cnum = buf.lex_abs_pos + buf.lex_curr_pos};
+)
+
+let disambiguate lexbuf txt =
+  let pos = ref 0 in
+  let len = String.length txt in
+  let is_digit c = c >= '0' && c <= '9' in
+  while !pos < len && is_digit txt.[!pos] do incr pos done;
+  let txt =
+    if !pos < len then (
+      set_lexeme_length lexbuf !pos;
+      String.sub txt 0 !pos
+    ) else
+      txt
+  in
+  TYPE_DISAMBIGUATOR txt
+
+let try_disambiguate lexbuf = function
+  | INT (txt, None) -> Some (disambiguate lexbuf txt)
+  | FLOAT (txt, _)  -> Some (disambiguate lexbuf txt)
+  | _ -> None
+
 (* Update the current location with file name and line number. *)
 
 let update_loc lexbuf file line absolute chars =
   let pos = lexbuf.lex_curr_p in
   let new_file = match file with
@@@@
   | ['+' '-'] symbolchar * as op
             { INFIXOP2 op }
   | "**" symbolchar * as op
             { INFIXOP4 op }
   | '%'     { PERCENT }
+  | '/'     { SLASH }
   | ['*' '/' '%'] symbolchar * as op
             { INFIXOP3 op }
   | '#' symbolchar_or_hash + as op
             { HASHOP op }
   | "let" kwdopchar dotsymbolchar * as op
@@@@
   | eof { EOF }
   | (_ as illegal_char)
       { error lexbuf (Illegal_character illegal_char) }
 
 and directive = parse
-  | ([' ' '\t']* (['0'-'9']+ as num) [' ' '\t']*
-        ("\"" ([^ '\010' '\013' '\"' ] * as name) "\"") as directive)
+  | ([' ' '\t']* (['0'-'9']+ as _num) [' ' '\t']*
+        ("\"" ([^ '\010' '\013' '\"' ] * as _name) "\"") as directive)
         [^ '\010' '\013'] *
       {
-        match int_of_string num with
-        | exception _ ->
-            (* PR#7165 *)
-            let explanation = "line number out of range" in
-            error lexbuf (Invalid_directive ("#" ^ directive, Some explanation))
-        | line_num ->
-           (* Documentation says that the line number should be
-              positive, but we have never guarded against this and it
-              might have useful hackish uses. *)
-            update_loc lexbuf (Some name) (line_num - 1) true 0;
-            token lexbuf
+        (* Line directives are not preserved by the lexer so we error out. *)
+        let explanation = "line directives are not supported" in
+        error lexbuf (Invalid_directive ("#" ^ directive, Some explanation))
       }
 and comment = parse
     "(*"
       { comment_start_loc := (Location.curr lexbuf) :: !comment_start_loc;
         store_lexeme lexbuf;
--- parser-upstream/parse.ml
+++ parser-standard/parse.ml
@@@@
 let maybe_skip_phrase lexbuf =
   match !last_token with
   | Parser.SEMISEMI | Parser.EOF -> ()
   | _ -> skip_phrase lexbuf
 
-type 'a parser =
-  (Lexing.lexbuf -> Parser.token) -> Lexing.lexbuf -> 'a
+type 'a parser = Lexing.position -> 'a Parser.MenhirInterpreter.checkpoint
 
 let wrap (parser : 'a parser) lexbuf : 'a =
   try
     Docstrings.init ();
     Lexer.init ();
-    let ast = parser token lexbuf in
+    let open Parser.MenhirInterpreter in
+    let rec fix_resume = function
+      | InputNeeded _ | Accepted _ | Rejected | HandlingError _ as cp -> cp
+      | Shifting (_, _, _) | AboutToReduce (_, _) as cp ->
+        fix_resume (resume ~strategy:`Simplified cp)
+    in
+    let rec offer_input lexbuf cp tok =
+      let ptok = Lexing.(tok, lexbuf.lex_start_p, lexbuf.lex_curr_p) in
+      match fix_resume (offer cp ptok) with
+      | InputNeeded _ as cp ->
+          offer_input lexbuf cp (token lexbuf)
+      | Accepted x -> Some x
+      | Rejected -> None
+      | Shifting (_, _, _) | AboutToReduce (_, _) ->
+          assert false
+      | HandlingError _ as cp' ->
+        match Lexer.try_disambiguate lexbuf tok with
+        | Some tok' -> offer_input lexbuf cp tok'
+        | None -> main_loop lexbuf cp'
+    and main_loop lexbuf = function
+      | InputNeeded _ as cp ->
+          offer_input lexbuf cp (token lexbuf)
+      | Accepted x -> Some x
+      | Rejected -> None
+      | Shifting (_, _, _) | AboutToReduce (_, _) | HandlingError _ as cp ->
+        main_loop lexbuf (resume ~strategy:`Simplified cp)
+    in
+    let ast =
+      match main_loop lexbuf (parser lexbuf.Lexing.lex_curr_p) with
+      | Some ast -> ast
+      | None -> raise Parsing.Parse_error
+    in
     Parsing.clear_parser();
     Docstrings.warn_bad_docstrings ();
     last_token := Parser.EOF;
     ast
   with
@@@@
      a production whose semantic action raises an exception.
 
    In either case, the parser will not attempt to read one token past
    the syntax error. *)
 
-let implementation = wrap Parser.implementation
-and interface = wrap Parser.interface
-and toplevel_phrase = wrap Parser.toplevel_phrase
-and use_file = wrap Parser.use_file
-and core_type = wrap Parser.parse_core_type
-and expression = wrap Parser.parse_expression
-and pattern = wrap Parser.parse_pattern
-let module_type = wrap Parser.parse_module_type
-let module_expr = wrap Parser.parse_module_expr
-
-let longident = wrap Parser.parse_any_longident
-let val_ident = wrap Parser.parse_val_longident
-let constr_ident= wrap Parser.parse_constr_longident
-let extended_module_path = wrap Parser.parse_mod_ext_longident
-let simple_module_path = wrap Parser.parse_mod_longident
-let type_ident = wrap Parser.parse_mty_longident
+let implementation = wrap Parser.Incremental.implementation
+and interface = wrap Parser.Incremental.interface
+and toplevel_phrase = wrap Parser.Incremental.toplevel_phrase
+and use_file = wrap Parser.Incremental.use_file
+and core_type = wrap Parser.Incremental.parse_core_type
+and expression = wrap Parser.Incremental.parse_expression
+and pattern = wrap Parser.Incremental.parse_pattern
+let module_type = wrap Parser.Incremental.parse_module_type
+let module_expr = wrap Parser.Incremental.parse_module_expr
+
+let longident = wrap Parser.Incremental.parse_any_longident
+let val_ident = wrap Parser.Incremental.parse_val_longident
+let constr_ident= wrap Parser.Incremental.parse_constr_longident
+let extended_module_path = wrap Parser.Incremental.parse_mod_ext_longident
+let simple_module_path = wrap Parser.Incremental.parse_mod_longident
+let type_ident = wrap Parser.Incremental.parse_mty_longident
 
 (* Error reporting for Syntaxerr *)
 (* The code has been moved here so that one can reuse Pprintast.tyvar *)
 
 let prepare_error err =
--- parser-upstream/parser.mly
+++ parser-standard/parser.mly
@@@@
   | "+", Pexp_constant(Pconst_integer _)
   | ("+" | "+."), Pexp_constant(Pconst_float _) -> desc
   | _ ->
       Pexp_apply(mkoperator ~loc:oploc ("~" ^ name), [Nolabel, arg])
 
+
+let local_loc = mknoloc "ocaml.local"
+let local_ext_loc = mknoloc "extension.local"
+
+let local_attr =
+  Attr.mk ~loc:Location.none local_loc (PStr [])
+
+let local_extension =
+  Exp.mk ~loc:Location.none (Pexp_extension(local_ext_loc, PStr []))
+
+let mkexp_stack ~loc exp =
+  ghexp ~loc (Pexp_apply(local_extension, [Nolabel, exp]))
+
+let mkpat_stack pat =
+  {pat with ppat_attributes = local_attr :: pat.ppat_attributes}
+
+let mktyp_stack typ =
+  {typ with ptyp_attributes = local_attr :: typ.ptyp_attributes}
+
+let wrap_exp_stack exp =
+  {exp with pexp_attributes = local_attr :: exp.pexp_attributes}
+
+let mkexp_local_if p ~loc exp =
+  if p then mkexp_stack ~loc exp else exp
+
+let mkpat_local_if p pat =
+  if p then mkpat_stack pat else pat
+
+let mktyp_local_if p typ =
+  if p then mktyp_stack typ else typ
+
+let wrap_exp_local_if p exp =
+  if p then wrap_exp_stack exp else exp
+
+let curry_attr =
+  Attr.mk ~loc:Location.none (mknoloc "ocaml.curry") (PStr [])
+
+let is_curry_attr attr =
+  attr.attr_name.txt = "ocaml.curry"
+
+let mktyp_curry typ =
+  {typ with ptyp_attributes = curry_attr :: typ.ptyp_attributes}
+
+let maybe_curry_typ typ =
+  match typ.ptyp_desc with
+  | Ptyp_arrow _ ->
+      if List.exists is_curry_attr typ.ptyp_attributes then typ
+      else mktyp_curry typ
+  | _ -> typ
+
+let global_loc = mknoloc "ocaml.global"
+
+let global_attr =
+  Attr.mk ~loc:Location.none global_loc (PStr [])
+
+let nonlocal_loc = mknoloc "ocaml.nonlocal"
+
+let nonlocal_attr =
+  Attr.mk ~loc:Location.none nonlocal_loc (PStr [])
+
+let mkld_global ld =
+  { ld with pld_attributes = global_attr :: ld.pld_attributes }
+
+let mkld_nonlocal ld =
+  { ld with pld_attributes = nonlocal_attr :: ld.pld_attributes }
+
+let mkld_global_maybe gbl ld =
+  match gbl with
+  | Global -> mkld_global ld
+  | Nonlocal -> mkld_nonlocal ld
+  | Nothing -> ld
+
 (* TODO define an abstraction boundary between locations-as-pairs
    and locations-as-Location.t; it should be clear when we move from
    one world to the other *)
 
 let mkexp_cons_desc consloc args =
@@@@
 %token <string * char option> FLOAT "42.0" (* just an example *)
 %token FOR                    "for"
 %token FUN                    "fun"
 %token FUNCTION               "function"
 %token FUNCTOR                "functor"
+%token GLOBAL                 "global_"
 %token GREATER                ">"
 %token GREATERRBRACE          ">}"
 %token GREATERRBRACKET        ">]"
 %token IF                     "if"
 %token IN                     "in"
@@@@
 %token LBRACKETPERCENTPERCENT "[%%"
 %token LESS                   "<"
 %token LESSMINUS              "<-"
 %token LET                    "let"
 %token <string> LIDENT        "lident" (* just an example *)
+%token LOCAL                  "local_"
 %token LPAREN                 "("
 %token LBRACKETAT             "[@"
 %token LBRACKETATAT           "[@@"
 %token LBRACKETATATAT         "[@@@"
 %token MATCH                  "match"
@@@@
 %token MINUSDOT               "-."
 %token MINUSGREATER           "->"
 %token MODULE                 "module"
 %token MUTABLE                "mutable"
 %token NEW                    "new"
+%token NONLOCAL               "nonlocal_"
 %token NONREC                 "nonrec"
 %token OBJECT                 "object"
 %token OF                     "of"
 %token OPEN                   "open"
 %token <string> OPTLABEL      "?label:" (* just an example *)
@@@@
 %token SEMI                   ";"
 %token SEMISEMI               ";;"
 %token HASH                   "#"
 %token <string> HASHOP        "##" (* just an example *)
 %token SIG                    "sig"
+%token SLASH                  "/"
 %token STAR                   "*"
 %token <string * Location.t * string option>
        STRING                 "\"hello\"" (* just an example *)
 %token <string * Location.t * string * Location.t * string option>
        QUOTED_STRING_EXPR     "{%hello|world|}"  (* just an example *)
@@@@
 %token <string * Location.t> COMMENT    "(* comment *)"
 %token <Docstrings.docstring> DOCSTRING "(** documentation *)"
 
 %token EOL                    "\\n"      (* not great, but EOL is unused *)
 
+%token <string> TYPE_DISAMBIGUATOR "2" (* just an example *)
+
 /* Precedences and associativities.
 
 Tokens and rules have precedences.  A reduce/reduce conflict is resolved
 in favor of the first rule (in source file order).  A shift/reduce conflict
 is resolved by comparing the precedence and associativity of the token to
@@@@
 %right    INFIXOP1                      /* expr (e OP e OP e) */
 %nonassoc below_LBRACKETAT
 %nonassoc LBRACKETAT
 %right    COLONCOLON                    /* expr (e :: e :: e) */
 %left     INFIXOP2 PLUS PLUSDOT MINUS MINUSDOT PLUSEQ /* expr (e OP e OP e) */
-%left     PERCENT INFIXOP3 STAR                 /* expr (e OP e OP e) */
+%left     PERCENT SLASH INFIXOP3 STAR                 /* expr (e OP e OP e) */
 %right    INFIXOP4                      /* expr (e OP e OP e) */
 %nonassoc prec_unary_minus prec_unary_plus /* unary - */
 %nonassoc prec_constant_constructor     /* cf. simple_expr (C versus C x) */
 %nonassoc prec_constr_appl              /* above AS BAR COLONCOLON COMMA */
 %nonassoc below_HASH
@@@@
 %nonassoc below_DOT
 %nonassoc DOT DOTOP
 /* Finally, the first tokens of simple_expr are above everything else. */
 %nonassoc BACKQUOTE BANG BEGIN CHAR FALSE FLOAT INT OBJECT
           LBRACE LBRACELESS LBRACKET LBRACKETBAR LIDENT LPAREN
-          NEW PREFIXOP STRING TRUE UIDENT
+          NEW PREFIXOP STRING TRUE UIDENT UNDERSCORE
           LBRACKETPERCENT QUOTED_STRING_EXPR
 
 
 /* Entry points */
 
@@@@
         { (* TODO review mkmod location *)
           Pmod_apply(me1, mkmod ~loc:$sloc (Pmod_structure [])) }
     | (* An extension. *)
       ex = extension
         { Pmod_extension ex }
+    | (* A hole. *)
+      UNDERSCORE
+        { Pmod_hole }
     )
     { $1 }
 ;
 
 (* A parenthesized module expression is a module expression that begins
@@@@
     { let seq = mkexp ~loc:$sloc (Pexp_sequence ($1, $5)) in
       let payload = PStr [mkstrexp seq []] in
       mkexp ~loc:$sloc (Pexp_extension ($4, payload)) }
 ;
 labeled_simple_pattern:
-    QUESTION LPAREN label_let_pattern opt_default RPAREN
-      { (Optional (fst $3), $4, snd $3) }
+    QUESTION LPAREN optional_local label_let_pattern opt_default RPAREN
+      { (Optional (fst $4), $5, mkpat_local_if $3 (snd $4)) }
   | QUESTION label_var
       { (Optional (fst $2), None, snd $2) }
-  | OPTLABEL LPAREN let_pattern opt_default RPAREN
-      { (Optional $1, $4, $3) }
+  | OPTLABEL LPAREN optional_local let_pattern opt_default RPAREN
+      { (Optional $1, $5, mkpat_local_if $3 $4) }
   | OPTLABEL pattern_var
       { (Optional $1, None, $2) }
-  | TILDE LPAREN label_let_pattern RPAREN
-      { (Labelled (fst $3), None, snd $3) }
+  | TILDE LPAREN optional_local label_let_pattern RPAREN
+      { (Labelled (fst $4), None, mkpat_local_if $3 (snd $4)) }
   | TILDE label_var
       { (Labelled (fst $2), None, snd $2) }
   | LABEL simple_pattern
       { (Labelled $1, None, $2) }
+  | LABEL LPAREN LOCAL pattern RPAREN
+      { (Labelled $1, None, mkpat_stack $4) }
   | simple_pattern
       { (Nolabel, None, $1) }
+  | LPAREN LOCAL let_pattern RPAREN
+      { (Nolabel, None, mkpat_stack $3) }
 ;
 
 pattern_var:
   mkpat(
       mkrhs(LIDENT)     { Ppat_var $1 }
@@@@
   | indexop_expr(qualified_dotop, expr_semi_list, LESSMINUS v=expr {Some v})
     { mk_indexop_expr user_indexing_operators ~loc:$sloc $1 }
   | expr attribute
       { Exp.attr $1 $2 }
 /* BEGIN AVOID */
+  (*
   | UNDERSCORE
      { not_expecting $loc($1) "wildcard \"_\"" }
+  *)
 /* END AVOID */
+  | LOCAL seq_expr
+     { mkexp_stack ~loc:$sloc $2 }
 ;
 %inline expr_attrs:
   | LET MODULE ext_attributes mkrhs(module_name) module_binding_body IN seq_expr
       { Pexp_letmodule($4, $5, $7), $3 }
   | LET EXCEPTION ext_attributes let_exception_declaration IN seq_expr
@@@@
         let od = Opn.mk $5 ~override:$3 ~loc:open_loc in
         Pexp_open(od, $7), $4 }
   | FUNCTION ext_attributes match_cases
       { Pexp_function $3, $2 }
   | FUN ext_attributes labeled_simple_pattern fun_def
-      { let (l,o,p) = $3 in
-        Pexp_fun(l, o, p, $4), $2 }
+      { let ext, attrs = $2 in
+        let (l,o,p) = $3 in
+        Pexp_fun(l, o, p, $4), (ext, attrs) }
   | FUN ext_attributes LPAREN TYPE lident_list RPAREN fun_def
-      { (mk_newtypes ~loc:$sloc $5 $7).pexp_desc, $2 }
+      { let ext, attrs = $2 in
+        (mk_newtypes ~loc:$sloc $5 $7).pexp_desc, (ext, attrs) }
   | MATCH ext_attributes seq_expr WITH match_cases
       { Pexp_match($3, $5), $2 }
   | TRY ext_attributes seq_expr WITH match_cases
       { Pexp_try($3, $5), $2 }
   | TRY ext_attributes seq_expr WITH error
@@@@
       { Pexp_send($1, $3) }
   | simple_expr op(HASHOP) simple_expr
       { mkinfix $1 $2 $3 }
   | extension
       { Pexp_extension $1 }
+  | UNDERSCORE
+      { Pexp_hole }
   | od=open_dot_declaration DOT mkrhs(LPAREN RPAREN {Lident "()"})
       { Pexp_open(od, mkexp ~loc:($loc($3)) (Pexp_construct($3, None))) }
   | mod_longident DOT LPAREN seq_expr error
       { unclosed "(" $loc($3) ")" $loc($5) }
   | LBRACE record_expr_content RBRACE
@@@@
     val_ident { mkpatvar ~loc:$sloc $1 }
 ;
 let_binding_body_no_punning:
     let_ident strict_binding
       { ($1, $2) }
-  | let_ident type_constraint EQUAL seq_expr
-      { let v = $1 in (* PR#7344 *)
+  | optional_local let_ident type_constraint EQUAL seq_expr
+      { let v = $2 in (* PR#7344 *)
         let t =
-          match $2 with
+          match $3 with
             Some t, None -> t
           | _, Some t -> t
           | _ -> assert false
         in
         let loc = Location.(t.ptyp_loc.loc_start, t.ptyp_loc.loc_end) in
         let typ = ghtyp ~loc (Ptyp_poly([],t)) in
-        let patloc = ($startpos($1), $endpos($2)) in
-        (ghpat ~loc:patloc (Ppat_constraint(v, typ)),
-         mkexp_constraint ~loc:$sloc $4 $2) }
-  | let_ident COLON poly(core_type) EQUAL seq_expr
-      { let patloc = ($startpos($1), $endpos($3)) in
-        (ghpat ~loc:patloc
-           (Ppat_constraint($1, ghtyp ~loc:($loc($3)) $3)),
-         $5) }
+        let patloc = ($startpos($2), $endpos($3)) in
+        let pat =
+          mkpat_local_if $1 (ghpat ~loc:patloc (Ppat_constraint(v, typ)))
+        in
+        let exp =
+          mkexp_local_if $1 ~loc:$sloc
+            (wrap_exp_local_if $1 (mkexp_constraint ~loc:$sloc $5 $3))
+        in
+        (pat, exp) }
+  | optional_local let_ident COLON poly(core_type) EQUAL seq_expr
+      { let patloc = ($startpos($2), $endpos($4)) in
+        let pat =
+          mkpat_local_if $1
+            (ghpat ~loc:patloc
+               (Ppat_constraint($2, ghtyp ~loc:($loc($4)) $4)))
+        in
+        let exp = mkexp_local_if $1 ~loc:$sloc $6 in
+        (pat, exp) }
   | let_ident COLON TYPE lident_list DOT core_type EQUAL seq_expr
       { let exp, poly =
           wrap_type_annotation ~loc:$sloc $4 $6 $8 in
         let loc = ($startpos($1), $endpos($6)) in
         (ghpat ~loc (Ppat_constraint($1, poly)), exp) }
   | pattern_no_exn EQUAL seq_expr
       { ($1, $3) }
   | simple_pattern_not_ident COLON core_type EQUAL seq_expr
       { let loc = ($startpos($1), $endpos($3)) in
         (ghpat ~loc (Ppat_constraint($1, $3)), $5) }
+  | LOCAL let_ident local_strict_binding
+      { ($2, mkexp_stack ~loc:$sloc $3) }
 ;
 let_binding_body:
   | let_binding_body_no_punning
       { let p,e = $1 in (p,e,false) }
 /* BEGIN AVOID */
@@@@
   | labeled_simple_pattern fun_binding
       { let (l, o, p) = $1 in ghexp ~loc:$sloc (Pexp_fun(l, o, p, $2)) }
   | LPAREN TYPE lident_list RPAREN fun_binding
       { mk_newtypes ~loc:$sloc $3 $5 }
 ;
+local_fun_binding:
+    local_strict_binding
+      { $1 }
+  | type_constraint EQUAL seq_expr
+      { wrap_exp_stack (mkexp_constraint ~loc:$sloc $3 $1) }
+;
+local_strict_binding:
+    EQUAL seq_expr
+      { $2 }
+  | labeled_simple_pattern local_fun_binding
+      { let (l, o, p) = $1 in ghexp ~loc:$sloc (Pexp_fun(l, o, p, $2)) }
+  | LPAREN TYPE lident_list RPAREN local_fun_binding
+      { mk_newtypes ~loc:$sloc $3 $5 }
+;
 %inline match_cases:
   xs = preceded_or_separated_nonempty_llist(BAR, match_case)
     { xs }
 ;
 match_case:
@@@@
     label_declaration                           { [$1] }
   | label_declaration_semi                      { [$1] }
   | label_declaration_semi label_declarations   { $1 :: $2 }
 ;
 label_declaration:
-    mutable_flag mkrhs(label) COLON poly_type_no_attr attributes
+    mutable_or_global_flag mkrhs(label) COLON poly_type_no_attr attributes
       { let info = symbol_info $endpos in
-        Type.field $2 $4 ~mut:$1 ~attrs:$5 ~loc:(make_loc $sloc) ~info }
+        let mut, gbl = $1 in
+        mkld_global_maybe gbl
+          (Type.field $2 $4 ~mut ~attrs:$5 ~loc:(make_loc $sloc) ~info) }
 ;
 label_declaration_semi:
-    mutable_flag mkrhs(label) COLON poly_type_no_attr attributes SEMI attributes
+    mutable_or_global_flag mkrhs(label) COLON poly_type_no_attr attributes
+      SEMI attributes
       { let info =
           match rhs_info $endpos($5) with
           | Some _ as info_before_semi -> info_before_semi
           | None -> symbol_info $endpos
        in
-       Type.field $2 $4 ~mut:$1 ~attrs:($5 @ $7) ~loc:(make_loc $sloc) ~info }
+       let mut, gbl = $1 in
+       mkld_global_maybe gbl
+         (Type.field $2 $4 ~mut ~attrs:($5 @ $7) ~loc:(make_loc $sloc) ~info) }
 ;
 
 /* Type Extensions */
 
 %inline str_type_extension:
@@@@
  *)
 function_type:
   | ty = tuple_type
     %prec MINUSGREATER
       { ty }
+  | ty = strict_function_type
+      { ty }
+;
+
+strict_function_type:
+  | mktyp(
+      label = arg_label
+      local = optional_local
+      domain = extra_rhs(tuple_type)
+      MINUSGREATER
+      codomain = strict_function_type
+        { Ptyp_arrow(label, mktyp_local_if local domain, codomain) }
+    )
+    { $1 }
   | mktyp(
       label = arg_label
+      arg_local = optional_local
       domain = extra_rhs(tuple_type)
       MINUSGREATER
-      codomain = function_type
-        { Ptyp_arrow(label, domain, codomain) }
+      ret_local = optional_local
+      codomain = tuple_type
+      %prec MINUSGREATER
+        { Ptyp_arrow(label,
+            mktyp_local_if arg_local domain,
+            mktyp_local_if ret_local (maybe_curry_typ codomain)) }
     )
     { $1 }
 ;
 %inline arg_label:
   | label = optlabel
@@@@
   | label = LIDENT COLON
       { Labelled label }
   | /* empty */
       { Nolabel }
 ;
+%inline optional_local:
+  | /* empty */
+    { false }
+  | LOCAL
+    { true }
+;
 (* Tuple types include:
    - atomic types (see below);
    - proper tuple types:                  int * int * int list
    A proper tuple type is a star-separated list of at least two atomic types.
  *)
@@@@
   | PLUS           {"+"}
   | PLUSDOT       {"+."}
   | PLUSEQ        {"+="}
   | MINUS          {"-"}
   | MINUSDOT      {"-."}
+  | SLASH          {"/"}
   | STAR           {"*"}
   | PERCENT        {"%"}
   | EQUAL          {"="}
   | LESS           {"<"}
   | GREATER        {">"}
@@@@
 label_longident:
     mk_longident(mod_longident, LIDENT) { $1 }
 ;
 type_longident:
     mk_longident(mod_ext_longident, LIDENT)  { $1 }
+  | LIDENT SLASH TYPE_DISAMBIGUATOR          { Lident ($1 ^ "/" ^ $3) }
 ;
 mod_longident:
     mk_longident(mod_longident, UIDENT)  { $1 }
 ;
+mod_ext_longident_:
+    UIDENT                          { Lident $1 }
+  | UIDENT SLASH TYPE_DISAMBIGUATOR { Lident ($1 ^ "/" ^ $3) }
+  | mod_ext_longident DOT UIDENT    { Ldot($1,$3) }
+;
 mod_ext_longident:
-    mk_longident(mod_ext_longident, UIDENT) { $1 }
+    mod_ext_longident_ { $1 }
   | mod_ext_longident LPAREN mod_ext_longident RPAREN
       { lapply ~loc:$sloc $1 $3 }
   | mod_ext_longident LPAREN error
       { expecting $loc($3) "module path" }
 ;
@@@@
 ;
 mutable_flag:
     /* empty */                                 { Immutable }
   | MUTABLE                                     { Mutable }
 ;
+mutable_or_global_flag:
+    /* empty */                                 { Immutable, Nothing }
+  | MUTABLE                                     { Mutable, Nothing }
+  | GLOBAL                                      { Immutable, Global }
+  | NONLOCAL                                    { Immutable, Nonlocal }
+;
 virtual_flag:
     /* empty */                                 { Concrete }
   | VIRTUAL                                     { Virtual }
 ;
 mutable_virtual_flags:
@@@@
   | FALSE { "false" }
   | FOR { "for" }
   | FUN { "fun" }
   | FUNCTION { "function" }
   | FUNCTOR { "functor" }
+  | NONLOCAL { "nonlocal_" }
   | IF { "if" }
   | IN { "in" }
   | INCLUDE { "include" }
   | INHERIT { "inherit" }
   | INITIALIZER { "initializer" }
   | LAZY { "lazy" }
   | LET { "let" }
+  | LOCAL { "local_" }
   | MATCH { "match" }
   | METHOD { "method" }
   | MODULE { "module" }
   | MUTABLE { "mutable" }
   | NEW { "new" }
--- parser-upstream/parsetree.mli
+++ parser-standard/parsetree.mli
@@@@
   | Pexp_letop of letop
       (** - [let* P = E0 in E1]
             - [let* P0 = E00 and* P1 = E01 in E1] *)
   | Pexp_extension of extension  (** [[%id]] *)
   | Pexp_unreachable  (** [.] *)
+  | Pexp_hole  (** [_] *)
 
 and case =
     {
      pc_lhs: pattern;
      pc_guard: expression option;
@@@@
       (** [functor(X : MT1) -> ME] *)
   | Pmod_apply of module_expr * module_expr  (** [ME1(ME2)] *)
   | Pmod_constraint of module_expr * module_type  (** [(ME : MT)] *)
   | Pmod_unpack of expression  (** [(val E)] *)
   | Pmod_extension of extension  (** [[%id]] *)
+  | Pmod_hole  (** [_] *)
 
 and structure = structure_item list
 
 and structure_item =
     {
--- parser-upstream/printast.ml
+++ parser-standard/printast.ml
@@@@
   | Pexp_extension (s, arg) ->
       line i ppf "Pexp_extension \"%s\"\n" s.txt;
       payload i ppf arg
   | Pexp_unreachable ->
       line i ppf "Pexp_unreachable"
+  | Pexp_hole ->
+      line i ppf "Pexp_hole"
 
 and value_description i ppf x =
   line i ppf "value_description %a %a\n" fmt_string_loc
        x.pval_name fmt_location x.pval_loc;
   attributes i ppf x.pval_attributes;
@@@@
       line i ppf "Pmod_unpack\n";
       expression i ppf e;
   | Pmod_extension (s, arg) ->
       line i ppf "Pmod_extension \"%s\"\n" s.txt;
       payload i ppf arg
+  | Pmod_hole ->
+      line i ppf "Pmod_hole"
 
 and structure i ppf x = list i structure_item ppf x
 
 and structure_item i ppf x =
   line i ppf "structure_item %a\n" fmt_location x.pstr_loc;
--- parser-upstream/printast.mli
+++ parser-standard/printast.mli
@@@@
 val top_phrase : formatter -> toplevel_phrase -> unit
 
 val expression: int -> formatter -> expression -> unit
 val structure: int -> formatter -> structure -> unit
 val payload: int -> formatter -> payload -> unit
+val core_type: int -> formatter -> core_type -> unit
+val module_type: int -> formatter -> module_type -> unit
